## 调试器的工作原理：第二章 - 断点
作者：Eli Bendersky &nbsp; 
译者：徐软件 &nbsp; [[原文链接](http://eli.thegreenplace.net/2011/01/27/how-debuggers-work-part-2-breakpoints)]


本文是**调试器的工作原理**系列文章的第二章。阅读本文前，希望读者已经阅读过[第一章](...)。

### 本文简介
笔者将展示一个调试器如何实现断点功能。断点功能是调试中的两大神级功能之一，另一个神级功能是观察指定的变量。第一章已经介绍了调试器的简单功能，但断点的实现依然迷雾重重。阅读完本文，一切都会明朗。

### 软件中断
为了在 x86 架构中实现断点功能，软件中断（又称为陷阱）必不可少。在深入介绍之前，笔者先简要说明两个概念，中断和陷阱。

一个 CPU 会有一个流水式的计算，一个指令接着一个指令[[注1](#1)]。为了响应异步事件，如输入输出、硬件定时器，CPU 使用了中断。一个硬件中断常常是一个专用的电子信号，绑定着一个响应电路。该电路能激活中断，并使得 CPU 停止当前计算、保存状态，然后跳转到一个预设的地址，该地址便是中断处理程序。当中断处理完成，CPU 恢复到停止前的状态继续运行。

软件中断的原理相似，实现稍有差别。CPU 支持特殊指令，使得软件能模拟中断。当特殊指令被执行，CPU 如同处理中断一般，停止正常计算、保存状态，然后跳转到一个中断处理程序。正是这些软件中断（或陷阱），现代操作系统得以实现一些无法想象的神奇功能，如任务调度、虚拟内存、内存保护、调试跟踪等。

一些编程错误（如除以零）也被 CPU 当做软件中断，并常常当异常处理。这些时候，硬件与软件的界限模糊了，因为非常难以说明异常的源头是硬件或软件。不过这已经不是本文要讨论的问题了，下面还是回到断点。

### `int 3` 理论
基于上文的知识，断点的实现原理可以简化为 CPU 上的一个特殊中断 `int 3`。在 x86 系统中，`int` 指 "trap instruction" —— 一个预定义的中断处理程序。x86 系统支持 `int` 指令，并且需要有一个 8 位的参数，所以理论上刻有有 256 个不同的中断。其中前 32 个中断是 CPU 为自己保留的，而 3 就是目前我们最关心的，它也称作“调试中断”（trap to debugger）。

下面是 CPU 的说明书中的一部分[[注2](#2)]：

> `int 3` 指令会产生一个特殊的单字节操作码，用于调用调试异常处理程序。（此单字节操作码意义非凡，它可以代替任何指令的第一个字节，不会影响其他指令）。

上面的说明非常重要，但现在解释为之尚早，下文会再次展开。

### `int 3` 实践
> 古人云：纸上得来终觉浅，绝知此事要躬行
>
> 程序员说：Talk is cheap, show me the code!

怎样才能用 `int 3` 实现断点？非常简单，一旦目标进程执行了指令 `int 3`，操作系统就会停止该目标进程[[注3](#3)]。在 Linux 系统中，操作系统同时会给目标进程发送一个信号 `SIGTRAP`。

回顾第一章中的内容可知，调试器进程能接受所有被跟踪进程的消息。读到这里，你应该明白了！

下面来看代码和例子。

### 手动设置断点
下面是一个带断点的程序，同时也是我们的目标进程。











[1] 从高层次观察是正确的。落实到具体执行，现在 CPU 用多核并行的执行多条指令，甚至执行顺序得不到保证，即排在流前面的不一定先执行。巧妙的 CPU 设计使得多核并行的运行结果与单核运行一致，所以整体依然可以视为单核执行。
[2] 摘自 Intel's Architecture software developer's manual, volume 2A。
[3] 操作系统如何能停止一个进程？因为操作系统本身为 `int 3` 注册了中断处理程序。
