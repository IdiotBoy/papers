## 调试器的工作原理
作者：Eli Bendersky &nbsp;&nbsp;&nbsp;&nbsp; 
翻译：徐软件 [[原文链接](http://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1)]

“调试器的工作原理”将是一个系列，本文是第一部分。我还不确定这个系列的文章会有几篇，也不确定包含哪些主题，下面将从基础开始。

###本文简介
`ptrace()` 是 Linux 的一个系统调用，本文会结合代码，介绍 `ptrace` 的主要构建模块。本文中的代码都是运行在 32 位 Ubuntu 系统中。注意，这些代码是系统相关的，虽然它也很容易移植到其他系统。

###动机
调试器可以启动一个程序然后跟踪，或者直接跟踪一个已有进程。调试的功能包括单步执行、断点设置、变量显示、堆栈跟踪。还有一些高级的调试功能，如计算表达式、调用程序中的函数、动态修改代码。

调试器已经发展的非常复杂，其基本原理却异常简单。调试器启动只需要有操作系统、编译器/链接器、用户代码。

###Linux 调试器 - ptrace
`ptrace`，号称 Linux 调试器中的瑞士军刀。它功能丰富，可以让父进程观察和控制子进程的执行，检查和改变子进程的核心映像、及寄存器。常用的工具如 gdb 就是基于 `ptrace` 实现的。`ptrace` 的介绍可以写一本书，本文仅根据例子介绍一些实用的功能。

###一个例子
下面的例子将用于单步跟踪。代码会一点点给出，并介绍其含义（点击[代码]()全部下载）。

这个例子的目的是，子进程执行用户命令，父进程跟踪子进程。首先是 `main` 函数：

	int main(int argc, char** argv)
	{
    	pid_t child_pid;

    	if (argc < 2) {
        	fprintf(stderr, "Expected a program name as argument\n");
        	return -1;
    	}

    	child_pid = fork();
    	if (child_pid == 0)
        	run_target(argv[1]);
    	else if (child_pid > 0)
        	run_debugger(child_pid);
    	else {
        	perror("fork");
        	return -1;
    	}

    	return 0;
	}

非常简单：new 一个子进程，满足 `if` 条件执行子进程 `target`，满足 `else if` 条件执行父进程 `debugger`。

子进程 `target` 如下：

	void run_target(const char* programname)
	{
		procmsg("target started. will run '%s'\n", programname);

		// 等待被跟踪
		if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
			perror("ptrace");
			return;
		}
	
		// 运行指定的程序
		execl(programname, programname, 0);
	}

其中比较有趣的是调用 `ptrace` 函数，其声明为（在 sys/ptrace.h）:

	long ptrace(enum __ptrace_request request, pid_t pid,
                 void *addr, void *data);
               

* `enum __ptrace_request request`：指示了 `ptrace` 要执行的命令
* `pid_t pid`: 指示 `ptrace` 要跟踪的进程
* `void *addr`: 指示要监控的内存地址
* `void *data`: 存放读取出的或者要写入的数据

`PTRACE_TRACEME` 表示该子进程将被父进程跟踪，交付这个进程的所有信号，都将使其停止（除了 `SIGKILL`），父进程通过 `wait()` 获知这一情况。

例子中 `ptrace` 的下一句是 `execl`，但它执行之前，操作系统内核会停止该子进程，并向父进程发消息。此时看一下父进程做了什么：

	void run_debugger(pid_t child_pid)
	{
    	int wait_status;
    	unsigned icounter = 0;
    	procmsg("debugger started\n");

	    // 等待子进程停止第一个指令
	    wait(&wait_status);

	    while (WIFSTOPPED(wait_status)) {
	        icounter++;
	        // 通知子进程执行下一个指令
	        if (ptrace(PTRACE_SINGLESTEP, child_pid, 0, 0) < 0) {
	            perror("ptrace");
	            return;
	        }

	        // 等待子进程停止下一个指令
	        wait(&wait_status);
	    }

	    procmsg("the child executed %u instructions\n", icounter);
	}




