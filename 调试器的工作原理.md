## 调试器的工作原理
作者：Eli Bendersky &nbsp;&nbsp;&nbsp;&nbsp; 
翻译：徐软件 [[原文链接](http://eli.thegreenplace.net/2011/01/23/how-debuggers-work-part-1)]

**调试器的工作原理**将是一个系列，本文是第一部分。我还不确定这个系列的文章会有几篇，也不确定包含哪些主题，下面将从基础开始。

###本文简介
`ptrace()` 是 Linux 的一个系统调用，本文会结合代码，介绍 `ptrace` 的主要构建模块。本文中的代码都是运行在 32 位 Ubuntu 系统中。注意，这些代码是系统相关的，当然它也很容易移植到其他系统。

###动机
常见的调试器可以启动一个程序然后跟踪，或者直接跟踪一个已有进程。调试的功能包括单步执行、断点设置、变量显示、堆栈跟踪。还有一些高级的调试功能，如计算表达式、调用程序中的函数、动态修改代码。

调试器发展到现在已经非常复杂，其基本原理却异常简单。调试器启动只需要有操作系统、编译器/链接器、用户代码。

###Linux 调试器 - ptrace
`ptrace`，号称 Linux 调试器中的瑞士军刀。它功能丰富，可以让父进程观察和控制子进程的执行，检查和改变子进程的核心映像、及寄存器。常用的工具如 gdb 就是基于 `ptrace` 实现的。`ptrace` 的介绍可以写一本书，本文仅根据例子介绍一些实用的功能。

###例子 - tracer
下面的例子将用于单步跟踪。代码会一点点给出，并介绍其含义（点击[代码]()全部下载）。

这个例子的内容是，子进程执行用户命令，父进程跟踪子进程。首先是 `main` 函数：

	int main(int argc, char** argv) {
    	if (argc < 2) {
        	fprintf(stderr, "Expected a program name as argument\n");
        	return -1;
    	}

    	pid_t child_pid;
    	child_pid = fork();

    	if (child_pid == 0)
        	run_target(argv[1]);
    	else if (child_pid > 0)
        	run_debugger(child_pid);
    	else {
        	perror("fork");
        	return -1;
    	}
    	return 0;
	}

非常简单：new 一个子进程，满足 `if` 条件执行子进程 `target`，满足 `else if` 条件执行父进程 `debugger`。

子进程 `target` 如下：

	void run_target(const char* programname)
	{
		procmsg("target started. will run '%s'\n", programname);

		// 等待被跟踪
		if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
			perror("ptrace");
			return;
		}
	
		// 运行指定的程序
		execl(programname, programname, 0);
	}

其中比较有趣的是调用 `ptrace` 函数，其声明为（在 sys/ptrace.h）:

	long ptrace(enum __ptrace_request request, pid_t pid,
                 void *addr, void *data);
               

* `enum __ptrace_request request`：指示了 `ptrace` 要执行的命令
* `pid_t pid`: 指示 `ptrace` 要跟踪的进程
* `void *addr`: 指示要监控的内存地址
* `void *data`: 存放读取出的或者要写入的数据

`PTRACE_TRACEME` 表示该子进程将被父进程跟踪，交付这个进程的所有信号，都将使其停止（除了 `SIGKILL`），父进程通过 `wait()` 获知这一情况。子进程之后所有调用 `exec()`，都会向父进程发送一个消息 `SIGTRAP`，于是父进程就获得了 `exec()` 将要执行的新任务的控制权限。

例子中 `ptrace` 的下一句是 `execl`，于是子进程会被操作系统内核会停止，并向父进程发消息，此时 `programmname` 还没有执行。此时看一下父进程做了什么：

	void run_debugger(pid_t child_pid) {
    	int wait_status;
    	unsigned icounter = 0;
    	procmsg("debugger started\n");

	    // 等待子进程停止在第一个指令
	    wait(&wait_status);

	    while (WIFSTOPPED(wait_status)) {
	        icounter++;
	        // 通知子进程执行下一个指令
	        if (ptrace(PTRACE_SINGLESTEP, child_pid, 0, 0) < 0) {
	            perror("ptrace");
	            return;
	        }

	        // 等待子进程停止在下一个指令
	        wait(&wait_status);
	    }

	    procmsg("the child executed %u instructions\n", icounter);
	}

之前提到，当子进程调用 `exec()` 时，会停止并发送一个消息 `SIGTRAP`，于是父进程的 `wait()` 获得了这一个消息。

这段代码中最有意思的是 `ptrace(PTRACE_SINGLESTEP, child_pid, 0, 0)` 命令，它通知操作系统，**请继续运行子进程 `child_pid`，只要执行下一个命令，然后停止**。然后子进程又发出停止的消息，如此循环，直到子进程不是被 stopped，一般是程序运行完了退出。

`icounter` 的作用是计算子进程的指令（instruction）数。所以这个简单的例子输入是一个可执行程序的名字，然后跟踪执行它，并报告输入程序的 CPU 指令数。下面我们实际测试一下。

###测试
编译下面代码，然后作为以上程序 tracer 的输入：

	#include <stdio.h>
	int main() {
    	printf("Hello, world!\n");
    	return 0;
	}

结果令人惊讶，tracer 跑了好一会儿，并且显示 CPU 指令有超过 100,000 个。